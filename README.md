# 🚀 Vue 3 系统化学习与源码解析指南

> 本项目旨在为 Vue 开发者提供一个系统、深入的学习路径，涵盖 Vue 3 的核心概念、最佳实践以及源码结构分析，帮助开发者从“会用”到“精通”。

## 🌟 核心概念：从 Options 到 Composition

Vue 3 在设计上最大的革新在于引入了**组合式 API (Composition API)**，它与传统的 **选项式 API (Options API)** 共同构成了 Vue 3 的开发范式。

### 1. 组合式 API (Composition API)

组合式 API 的核心目标是解决 Options API 在大型组件中逻辑分散的问题，显著提升代码的组织性、可读性和逻辑复用性。它允许开发者将一个功能相关的逻辑代码集中在一个函数中，而不是分散在 `data`、`methods`、`computed` 等选项中。

| 关键 API                    | 描述                                                       | 适用场景                              |
| :-------------------------- | :--------------------------------------------------------- | :------------------------------------ |
| `setup()`                   | 组件逻辑的入口函数，在组件创建之前执行。                   | 组织所有 Composition API 逻辑的起点。 |
| `ref()`                     | 创建一个响应式引用，常用于包装**基本类型**数据。           | 计数器、布尔值等简单状态。            |
| `reactive()`                | 创建一个响应式对象或数组，常用于包装**复杂类型**数据。     | 表单数据、列表数据等复杂状态。        |
| `computed()`                | 创建一个计算属性，其值会根据响应式依赖自动更新。           | 需要基于现有状态计算出新值的场景。    |
| `watch()` / `watchEffect()` | 响应式地监听一个或多个数据源，并在数据源变化时执行副作用。 | 执行异步操作、DOM 操作或调试。        |

### 2. 响应式系统 (Reactivity System)

Vue 3 的响应式系统是其高性能的基础，它彻底告别了 Vue 2 中基于 `Object.defineProperty` 的实现，转而使用 **ES6 Proxy**。

**Proxy 的核心优势**在于：

1. **全面覆盖：** 能够监听对象属性的**添加**和**删除**，这是 `Object.defineProperty` 无法做到的。
2. **数组优化：** 能够直接监听数组索引和 `length` 属性的变化，无需像 Vue 2 那样对数组方法进行重写。

这一改进使得 Vue 3 的响应式系统更加健壮、高效，并且从根本上解决了 Vue 2 中常见的响应式限制问题 [1]。

## ⚙️ 源码结构解析：Monorepo 架构

Vue 3 源码采用了 **Monorepo**（单一代码仓库）的管理方式，所有模块都被拆分成独立的包，位于 `packages` 目录下。这种结构有利于模块间的解耦、独立测试和版本管理。

| 模块名称          | 对应目录        | 核心职责                                                     | 学习重点                                                     |
| :---------------- | :-------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Reactivity**    | `reactivity`    | 独立的响应式系统，提供 `ref`, `reactive`, `effect` 等核心函数。 | Proxy 的实现细节、`track`（收集依赖）和 `trigger`（触发更新）机制。 |
| **Runtime Core**  | `runtime-core`  | 平台无关的运行时核心，包含 VNode、Diff 算法、组件实例、生命周期。 | 虚拟 DOM 的创建与更新、`patch` 算法（Diff 算法）、组件挂载流程。 |
| **Runtime DOM**   | `runtime-dom`   | 针对浏览器的运行时，实现 DOM 挂载、更新、事件处理。          | 如何将 `runtime-core` 的 VNode 渲染到真实的浏览器 DOM 上。   |
| **Compiler Core** | `compiler-core` | 平台无关的模板编译器核心，负责解析、转换、生成代码。         | 模板解析（Parse）、AST 转换（Transform）、代码生成（Generate）流程。 |
| **Compiler SFC**  | `compiler-sfc`  | 单文件组件 (SFC) 编译器，处理 `<script>`, `<template>`, `<style>`。 | 如何将 `.vue` 文件编译成可执行的 JavaScript 模块。           |
| **Shared**        | `shared`        | 存放 Vue 3 各模块共享的工具函数和常量。                      | 了解常用的工具函数，如类型判断、缓存等。                     |

### 学习路径建议

要深入学习 Vue 3 源码，建议从以下两个核心模块入手：

1. **`packages/reactivity`**: 这是 Vue 3 的基石。理解 `Proxy` 如何实现深度响应式，以及依赖收集（`track`）和派发更新（`trigger`）的机制，是掌握整个框架的关键。
2. **`packages/runtime-core`**: 这是 Vue 3 的渲染核心。重点关注 **VNode** 的结构、**Diff 算法**（尤其是快速 Diff 算法）以及组件的生命周期管理。

## 🛠️ 学习资源与实践

### 官方文档与指南

- **Vue.js 官方文档 [2]**: 学习 Vue 3 核心概念、API 和最佳实践的首选资源。
- **Vue 3 源码仓库 [3]**: 直接阅读源码是最高效的学习方式。建议从 `packages/reactivity` 开始。

### 实践项目

- **Vue 3 官方示例**: 学习如何使用 Composition API 构建实际应用。
- **简易版 Vue 3 实现**: 尝试自己动手实现一个简化的 Vue 3 核心功能（如响应式系统和最小化渲染器），加深对原理的理解。

---

## 📚 参考文献

[1] Vue.js - 响应式基础 - Vue 3 官方文档
[2] Vue.js - 简介 - Vue 3 官方文档
[3] vuejs/core - GitHub 仓库
